List :: struct {
    data:   []u32
    length:   u32   // Could be removed once we have data.length
    capacity: u32
}

create_list :: fn(initialCapacity : u32) -> List {
    return List {
        .data     = [initialCapacity]u32,
        .length   = 0,
        .capacity = initialCapacity,
    }
}

at :: fn(this : List, index: u32) -> u32 {
    if index < this.length {
        return this.data[index]
    }
    // TODO Handle exception
    return 255
}

// TODO use memcopy
grow :: fn(this: List) -> void {
    this.capacity = this.capacity * 2
    data2 :: [this.capacity]u32
    for (i := 0; i < this.length; i = i + 1) {
        data2[i] = this.data[i]
    }
    this.data = data2
}

push :: fn(this: List, item: u32) {
    if this.length >= this.capacity {
        grow(this)
    }
    this.length = this.length + 1
    this.data[this.length] = item
}

empty :: fn(this: List) -> boolean {
    return this.length == 0
}

pop:: fn(this: List) -> u32 {
    this.length = this.length - 1
    return this.data[this.length]
}